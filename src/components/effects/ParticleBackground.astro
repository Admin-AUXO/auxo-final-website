---
import '../../styles/components/particle-background.css';
---

<div id="particle-background" class="fixed inset-0 pointer-events-none" aria-hidden="true" data-particle-container>
  <canvas id="particle-canvas"></canvas>
</div>

<script>
  let particleSystem: InstanceType<typeof import("../../scripts/particle-system").GalaxyParticleSystem> | null = null;
  let isInitialized = false;

  async function initParticleSystem() {
    if (typeof window === "undefined" || isInitialized) return;
    if (window.matchMedia("(prefers-reduced-motion: reduce)").matches) return;

    const canvas = document.getElementById("particle-canvas") as HTMLCanvasElement;
    const container = document.getElementById("particle-background");
    if (!canvas || !container) return;

    try {
      const { GalaxyParticleSystem } = await import("../../scripts/particle-system");
      Object.assign(container.style, { display: "block", opacity: "1", visibility: "visible" });
      particleSystem = new GalaxyParticleSystem(canvas);
      isInitialized = true;
    } catch (error) {
      if (import.meta.env.DEV) {
        console.error("Particle system failed:", error);
      }
    }
  }

  function cleanup() {
    if (particleSystem) {
      particleSystem.destroy();
      particleSystem = null;
    }
    isInitialized = false;
  }

  function waitForInit() {
    if (document.readyState === "loading") {
      document.addEventListener("DOMContentLoaded", waitForInit, { once: true });
      return;
    }
    const canvas = document.getElementById("particle-canvas");
    if (!canvas) {
      setTimeout(waitForInit, 100);
      return;
    }
    initParticleSystem();
  }

  if (document.readyState !== "loading") {
    waitForInit();
  } else {
    document.addEventListener("DOMContentLoaded", waitForInit, { once: true });
  }

  let lastPath = window.location.pathname;
  
  document.addEventListener("astro:before-swap", cleanup);
  document.addEventListener("astro:page-load", () => {
    const currentPath = window.location.pathname;
    if (currentPath !== lastPath) {
      setTimeout(waitForInit, 50);
      lastPath = currentPath;
    }
  });

  (function observeThemeChange() {
    if (typeof window === 'undefined') return;
    
    let lastTheme: 'dark' | 'light' = document.documentElement.classList.contains('dark') ? 'dark' : 'light';
    
    const themeObserver = new MutationObserver(() => {
      const currentTheme = document.documentElement.classList.contains('dark') ? 'dark' : 'light';
      if (lastTheme !== currentTheme) {
        cleanup();
        setTimeout(waitForInit, 100);
        lastTheme = currentTheme;
      }
    });
    
    themeObserver.observe(document.documentElement, {
      attributes: true,
      attributeFilter: ['class'],
    });
  })();
</script>

